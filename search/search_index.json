{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#dopus","title":"Dopus","text":"<p>Minimal easy-to-use framework for creating agentic applications.</p>"},{"location":"#overview","title":"Overview","text":"<p>Dopus is a lightweight, zero-dependency framework for AI agent application development. It contains simple abstractions that enable flexibility, simplicity, and transparency for the developer. Dopus is designed for building AI agents and their tools on top of existing LLM providers. It doesn't include any agents or tools out of the box.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>For more information on how to get started with Dopus, please refer to our Getting Started guide.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Please see our Contributing Guide for more details on how to get started.</p>"},{"location":"#license","title":"License","text":"<p>Dopus is released under the MIT License. See the LICENSE details.</p>"},{"location":"CONTRIBUTING/","title":"Contributing","text":""},{"location":"CONTRIBUTING/#contributing-to-dopus","title":"Contributing to Dopus","text":"<p>Thank you for your interest in contributing to Dopus! We welcome contributions from everyone and are grateful for even the smallest of improvements.</p>"},{"location":"CONTRIBUTING/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Getting Started</li> <li>Setting Up the Development Environment</li> <li>Making Changes</li> <li>Submitting a Pull Request</li> <li>Code Style and Guidelines</li> <li>Running Tests</li> <li>Reporting Bugs</li> <li>Feature Requests</li> </ol>"},{"location":"CONTRIBUTING/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally    <pre><code>git clone https://github.com/[YourUsername]/dopus.git\n</code></pre></li> <li>Create a new branch for your feature or bug fix    <pre><code>git checkout -b feature/your-feature-name\n</code></pre></li> </ol>"},{"location":"CONTRIBUTING/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":"<ol> <li>Ensure you have Python 3.7+ installed on your system.</li> <li>Install the required dependencies:    <pre><code>pip install -r requirements.txt\n</code></pre></li> <li>Set up your OpenAI API key in a <code>.env</code> file:    <pre><code>OPENAI_API_KEY=your_api_key_here\n</code></pre></li> </ol>"},{"location":"CONTRIBUTING/#making-changes","title":"Making Changes","text":"<ol> <li>Make your changes in your feature branch</li> <li>Add your changes    <pre><code>git add .\n</code></pre></li> <li>Commit your changes with a descriptive commit message    <pre><code>git commit -m \"Add a brief description of your changes\"\n</code></pre></li> <li>Push your changes to your fork on GitHub    <pre><code>git push origin feature/your-feature-name\n</code></pre></li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<ol> <li>Go to the original Dopus repository on GitHub</li> <li>Click on \"Pull Requests\" and then the \"New Pull Request\" button</li> <li>Select your fork and the feature branch you created</li> <li>Add a title and description for your pull request</li> <li>Click \"Create Pull Request\"</li> </ol>"},{"location":"CONTRIBUTING/#code-style-and-guidelines","title":"Code Style and Guidelines","text":"<ul> <li>Follow PEP 8 guidelines for Python code</li> <li>Use meaningful variable and function names</li> <li>Write docstrings for classes and functions</li> <li>Keep functions small and focused on a single task</li> <li>Use type hints where appropriate</li> </ul>"},{"location":"CONTRIBUTING/#running-tests","title":"Running Tests","text":"<p>We use the <code>DopusTest</code> framework for testing. To run tests:</p> <ol> <li>Navigate to the <code>dopus/test</code> directory</li> <li>Run the test file:    <pre><code>python dopus_test.py\n</code></pre></li> </ol> <p>To add new tests, use the <code>@test</code> or <code>@test_multi</code> decorators as shown in the existing test files.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#api-reference","title":"API Reference","text":"<ul> <li>Agent</li> <li>Convo</li> <li>Provider</li> <li>ToolRunner</li> <li>tool</li> </ul>"},{"location":"api/agent/","title":"Agent","text":""},{"location":"api/agent/#agent","title":"Agent","text":""},{"location":"api/agent/#dopus.core.Agent","title":"dopus.core.Agent","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class of an agent capable of running tools and managing conversations. The agent interfaces with a language model (LLM) and  has access to various tools through the tool registry. It is designed to handle conversations where tools may be called upon dynamically.</p> <p>Attributes:</p> Name Type Description <code>provider</code> <code>Provider</code> <p>The language model provider used by the agent.</p> <code>name</code> <code>str</code> <p>The name of the agent.</p> <code>convo</code> <code>Convo</code> <p>Conversation handler that manages the dialogue context.</p> <code>registry</code> <code>Convo</code> <p>A registry of tools that can be utilized by the agent.</p> <code>tool_manager</code> <code>ToolRunner</code> <p>Manager that handles tool execution and lifecycle events.</p>"},{"location":"api/agent/#dopus.core.Agent.__init__","title":"__init__","text":"<pre><code>__init__(provider: Provider, name: str = 'Agent', convo: Convo = None, registry: dict = None, tool_manager: ToolRunner = None)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the agent.</p> <code>'Agent'</code> <code>provider</code> <code>Provider</code> <p>language model provider instance.</p> required"},{"location":"api/agent/#dopus.core.Agent.get_actions","title":"get_actions","text":"<pre><code>get_actions()\n</code></pre> <p>Get the list of actions the agent has taken</p>"},{"location":"api/agent/#dopus.core.Agent.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Resets the conversation context for the agent.  Clears the current conversation history.</p>"},{"location":"api/agent/#dopus.core.Agent.run","title":"run","text":"<pre><code>run(message: str = None)\n</code></pre> <p>Runs the agent, initiating a conversation or tool execution loop.  If a message is provided, it appends it to the conversation.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message from the user to be processed by the agent.</p> <code>None</code> <p>Returns:</p> Type Description <p>Result of the tool execution loop managed by the tool manager.</p>"},{"location":"api/agent/#dopus.core.Agent.stop","title":"stop","text":"<pre><code>stop(result=None)\n</code></pre> <p>Stops the current tool execution or conversation flow and returns a result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <p>Optional result to return when stopping.</p> <code>None</code>"},{"location":"api/agent/#dopus.core.Agent.on_tool_use","title":"on_tool_use","text":"<pre><code>on_tool_use(tool: str, func)\n</code></pre> <p>Registers a callback function to be triggered when a tool is used.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>str</code> <p>Name of the tool.</p> required <code>func</code> <p>Function to be called when the tool is triggered.</p> required"},{"location":"api/agent/#dopus.core.Agent.add_tool","title":"add_tool","text":"<pre><code>add_tool(tool: str)\n</code></pre> <p>Adds a tool by name to the tool manager, making it available for the agent to use.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>str</code> <p>Name of the tool to add.</p> required"},{"location":"api/agent/#dopus.core.Agent.add_tools","title":"add_tools","text":"<pre><code>add_tools(tools: list)\n</code></pre> <p>Adds a list of tools to the tool manager</p> <p>Parameters:</p> Name Type Description Default <code>tools</code> <code>list</code> <p>List of tool names to add.</p> required"},{"location":"api/agent/#dopus.core.Agent.prompt","title":"prompt  <code>abstractmethod</code>","text":"<pre><code>prompt() -&gt; str\n</code></pre> <p>Abstract method to provide the agent's system prompt or message.  Must be implemented by subclasses.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The prompt or message that represents the agent's behavior.</p>"},{"location":"api/convo/","title":"Convo","text":""},{"location":"api/convo/#convo","title":"Convo","text":""},{"location":"api/convo/#dopus.core.Convo","title":"dopus.core.Convo","text":"<p>A class to manage the conversational context window.</p> <p>Attributes:</p> Name Type Description <code>__messages</code> <code>List[Dict[str, Any]]</code> <p>A list of messages.</p>"},{"location":"api/convo/#dopus.core.Convo.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre>"},{"location":"api/convo/#dopus.core.Convo.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clears all messages in the conversation.</p>"},{"location":"api/convo/#dopus.core.Convo.add_tool_call","title":"add_tool_call","text":"<pre><code>add_tool_call(metadata: Dict[str, Any], result: Any) -&gt; None\n</code></pre> <p>Adds a tool call and its result to the conversation.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>Dict[str, Any]</code> <p>Metadata about the tool call.</p> required <code>result</code> <code>Any</code> <p>The result of the tool call.</p> required"},{"location":"api/convo/#dopus.core.Convo.append","title":"append","text":"<pre><code>append(role: str, message: Dict[str, Any], msg_type: str = 'default') -&gt; None\n</code></pre> <p>Appends a message to the conversation.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>str</code> <p>The role of the message sender (e.g., 'user', 'assistant').</p> required <code>message</code> <code>Dict[str, Any]</code> <p>The message content.</p> required <code>msg_type</code> <code>str</code> <p>The type of the message. Defaults to \"default\".</p> <code>'default'</code>"},{"location":"api/convo/#dopus.core.Convo.get_all_of_type","title":"get_all_of_type","text":"<pre><code>get_all_of_type(msg_type: str) -&gt; List[Dict[str, Any]]\n</code></pre> <p>Retrieves all messages of a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>msg_type</code> <code>str</code> <p>The type of messages to retrieve.</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of messages of the specified type.</p>"},{"location":"api/convo/#dopus.core.Convo.remove_all_of_type","title":"remove_all_of_type","text":"<pre><code>remove_all_of_type(msg_type: str) -&gt; None\n</code></pre> <p>Removes all messages of a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>msg_type</code> <code>str</code> <p>The type of messages to remove.</p> required"},{"location":"api/convo/#dopus.core.Convo.get_messages","title":"get_messages","text":"<pre><code>get_messages() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Retrieves all messages in the conversation.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of all messages.</p>"},{"location":"api/provider/","title":"Provider","text":""},{"location":"api/provider/#provider","title":"Provider","text":""},{"location":"api/provider/#dopus.core.Provider","title":"dopus.core.Provider","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class to manage requests and responses to LLM providers. Core responsibilities:     - transforming Convo messages into the format the LLM expects      - transforming tools into the correct format for making the API request     - extracting data from the response of the API call</p> <p>Attributes:</p> Name Type Description <code>__messages</code> <code>List[Dict[str, Any]]</code> <p>A list of messages.</p>"},{"location":"api/provider/#dopus.core.Provider.__init__","title":"__init__","text":"<pre><code>__init__(model: str) -&gt; None\n</code></pre> <p>:param model: The model to be used by the provider.</p>"},{"location":"api/provider/#dopus.core.Provider.request","title":"request  <code>abstractmethod</code>","text":"<pre><code>request(messages: List[Dict[str, Any]], registry: Any, tools: Optional[List[Any]] = None, system_prompt: str = '') -&gt; Any\n</code></pre> <p>Make the completion request to the llm provider</p> <p>:param messages: List of message dictionaries. :param registry: The registry object. :param tools: Optional list of tools. :param system_prompt: Optional system prompt. :return: The response from the request.</p>"},{"location":"api/provider/#dopus.core.Provider.get_tools","title":"get_tools  <code>abstractmethod</code>","text":"<pre><code>get_tools(tools: List[Any], registry: Any) -&gt; List[Any]\n</code></pre> <p>Get a list of tools.</p> <p>:param tools: List of tools. :param registry: The registry object. :return: List of tools.</p>"},{"location":"api/provider/#dopus.core.Provider.extract_tool_call_data","title":"extract_tool_call_data  <code>abstractmethod</code>","text":"<pre><code>extract_tool_call_data(tool_call: Dict[str, Any]) -&gt; Any\n</code></pre> <p>Extract data from a tool call.</p> <p>:param tool_call: The tool call dictionary. :return: Extracted data.</p>"},{"location":"api/provider/#dopus.core.Provider.build_log","title":"build_log  <code>abstractmethod</code>","text":"<pre><code>build_log(response: Any, messages: List[Dict[str, Any]], result: Any, tools: List[Any]) -&gt; Dict[str, Any]\n</code></pre> <p>Build a log from a response, messages, result, and tools.</p> <p>:param response: The response object. :param messages: List of message dictionaries. :param result: The result object. :param tools: List of tools. :return: The log dictionary.</p>"},{"location":"api/provider/#dopus.core.Provider.get_tool_calls","title":"get_tool_calls  <code>abstractmethod</code>","text":"<pre><code>get_tool_calls(response: Any) -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get tool calls from a response.</p> <p>:param response: The response object. :return: List of tool call dictionaries.</p>"},{"location":"api/provider/#dopus.core.Provider.on_stop","title":"on_stop","text":"<pre><code>on_stop(convo: Convo, result: Optional[Any] = None) -&gt; None\n</code></pre> <p>Handle when the agentic loop stops.</p> <p>:param convo: The conversation object. :param result: Optional result to be processed.</p>"},{"location":"api/provider/#dopus.core.Provider.format_messages","title":"format_messages","text":"<pre><code>format_messages(messages: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]\n</code></pre> <p>Format a list of messages.</p> <p>:param messages: List of message dictionaries. :return: List of formatted message dictionaries.</p>"},{"location":"api/tool/","title":"Tool","text":""},{"location":"api/tool/#tool","title":"tool","text":""},{"location":"api/tool/#dopus.core.tool","title":"dopus.core.tool","text":""},{"location":"api/tool/#dopus.core.tool.tool","title":"tool","text":"<pre><code>tool(name=None, description=None, parameters=None, required=None, registry=tool_registry)\n</code></pre> <p>Decorator to register a function as a tool.</p> <p>This decorator adds metadata to the function and registers it in the tool registry.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Custom name for the tool. Defaults to the function name.</p> <code>None</code> <code>description</code> <code>str</code> <p>Description of what the tool does.</p> <code>None</code> <code>parameters</code> <code>dict</code> <p>A dictionary of parameters the tool accepts.</p> <code>None</code> <code>required</code> <code>list</code> <p>A list of required parameter names.</p> <code>None</code> <code>registry</code> <code>dict</code> <p>The registry to store the tool in. Defaults to tool_registry.</p> <code>tool_registry</code> <p>Returns:</p> Name Type Description <code>callable</code> <p>The decorated function.</p>"},{"location":"api/toolrunner/","title":"Toolrunner","text":""},{"location":"api/toolrunner/#toolrunner","title":"ToolRunner","text":""},{"location":"api/toolrunner/#dopus.core.ToolRunner","title":"dopus.core.ToolRunner","text":"<p>A class for managing and executing tools from LLM requests.</p> <p>This class handles tool execution for a set of tools that can be used by an AI agent in a conversation.</p>"},{"location":"api/toolrunner/#dopus.core.ToolRunner.Event","title":"Event","text":"<p>               Bases: <code>Enum</code></p> <p>Enum defining various events that can occur during tool execution.</p>"},{"location":"api/toolrunner/#dopus.core.ToolRunner.__init__","title":"__init__","text":"<pre><code>__init__(tools=None, registry=None)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tools</code> <code>list</code> <p>Initial list of tools to add.</p> <code>None</code> <code>registry</code> <code>dict</code> <p>Custom tool registry to use.</p> <code>None</code>"},{"location":"api/toolrunner/#dopus.core.ToolRunner.on_event","title":"on_event","text":"<pre><code>on_event(event: Event, callback)\n</code></pre> <p>Register a callback function for a specific event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event to listen for.</p> required <code>callback</code> <code>callable</code> <p>The function to call when the event occurs.</p> required"},{"location":"api/toolrunner/#dopus.core.ToolRunner.on","title":"on","text":"<pre><code>on(tool, callback)\n</code></pre> <p>Register a callback function for a specific tool.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>str</code> <p>The name of the tool.</p> required <code>callback</code> <code>callable</code> <p>The function to call when the tool is used.</p> required"},{"location":"api/toolrunner/#dopus.core.ToolRunner.add_tool","title":"add_tool","text":"<pre><code>add_tool(tool, agent=None)\n</code></pre> <p>Add a tool to the ToolRunner.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>str</code> <p>The name of the tool to add.</p> required <code>agent</code> <code>object</code> <p>The agent object to attach the tool to.</p> <code>None</code>"},{"location":"api/toolrunner/#dopus.core.ToolRunner.add_tools","title":"add_tools","text":"<pre><code>add_tools(tools, agent=None)\n</code></pre> <p>Add multiple tools to the ToolRunner.</p> <p>Parameters:</p> Name Type Description Default <code>tools</code> <code>list</code> <p>A list of tool names to add.</p> required <code>agent</code> <code>object</code> <p>The agent object to attach the tools to.</p> <code>None</code>"},{"location":"api/toolrunner/#dopus.core.ToolRunner.remove_tool","title":"remove_tool","text":"<pre><code>remove_tool(tool)\n</code></pre> <p>Remove a tool from the ToolRunner.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>str</code> <p>The name of the tool to remove.</p> required"},{"location":"api/toolrunner/#dopus.core.ToolRunner.loop","title":"loop","text":"<pre><code>loop(convo, llm, agent=None)\n</code></pre> <p>Start the main execution loop for processing conversations.</p> <p>Parameters:</p> Name Type Description Default <code>convo</code> <code>object</code> <p>The conversation object.</p> required <code>llm</code> <code>object</code> <p>The language model object.</p> required <code>agent</code> <code>object</code> <p>The agent object.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the final result and a list of actions performed.</p>"},{"location":"api/toolrunner/#dopus.core.ToolRunner.execute","title":"execute","text":"<pre><code>execute(convo, llm, agent=None)\n</code></pre> <p>Execute a single step in the conversation processing.</p> <p>Parameters:</p> Name Type Description Default <code>convo</code> <code>object</code> <p>The conversation object.</p> required <code>llm</code> <code>object</code> <p>The language model object.</p> required <code>agent</code> <code>object</code> <p>The agent object.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the result and a log of the execution.</p>"},{"location":"api/toolrunner/#dopus.core.ToolRunner.stop","title":"stop","text":"<pre><code>stop(result=None)\n</code></pre> <p>Stop the execution loop.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>any</code> <p>The final result to return.</p> <code>None</code>"},{"location":"guides/getting_started/","title":"Getting Started","text":""},{"location":"guides/getting_started/#overview","title":"Overview","text":"<p>In this getting started guide we will build a basic \"Hello World\" agent. The full code can be found at the bottom of this page.</p>"},{"location":"guides/getting_started/#installation","title":"Installation","text":"<p>To install dopus run:</p> <pre><code>pip install dopus\n</code></pre> <p>Let's also install <code>python-dotenv</code> and <code>openai</code>:</p> <pre><code>pip install python-dotenv openai\n</code></pre>"},{"location":"guides/getting_started/#setup","title":"Setup","text":"<p>Create a <code>.env</code> file with your OpenAI API key:</p> <pre><code>OPENAI_API_KEY={YOUR_API_KEY_HERE}\n</code></pre>"},{"location":"guides/getting_started/#hello-world-agent","title":"Hello World Agent","text":"<p>Let's create a simple Hello World agent that uses tools and interacts with the user. </p> <p>Start by loading the environment variables:</p> <pre><code># First load the environment variables\nimport os\nimport dotenv\ndotenv.load_dotenv()\n</code></pre> <p>Then let's define our agent and set the prompt:</p> <pre><code>from dopus.provider import OpenAI\nfrom dopus.core import Agent, tool\n\nclass HelloAgent(Agent):\n\n    def prompt(self):\n        return \"You are a friendly AI that greets users.\"\n</code></pre> <p>Then we will add a tool to enable the agent to say hello:</p> <pre><code>from dopus.core import Agent, tool\n\nclass HelloAgent(Agent):\n\n    # Previous code...\n\n    @tool(description=\"Greet the user\")\n    def say_hello(self):\n        print(f\"Agent: Hello World!\")\n        self.stop() # Stop the agentic loop\n</code></pre> <p>Then we will instantiate the openai provider and  run the agent and watch it say hello!</p> <pre><code>provider = OpenAI(os.getenv('OPENAI_API_KEY'))\nagent = HelloAgent(provider)\nagent.run()\n</code></pre> <p>Full Code:</p> <p><pre><code># First load the environment variables\nimport os\nimport dotenv\ndotenv.load_dotenv()\n\nfrom dopus.provider import OpenAI\nfrom dopus.core import Agent, tool\n\nclass HelloAgent(Agent):\n\n    def prompt(self):\n        return \"You are a friendly AI that greets users.\"\n\n    @tool(description=\"Greet the user\")\n    def say_hello(self):\n        print(f\"Agent: Hello World!\")\n        self.stop() # Stop the agentic loop\n\nprovider = OpenAI(os.getenv('OPENAI_API_KEY'))\nagent = HelloAgent(provider)\nagent.run()\n</code></pre> Output: <pre><code>Agent: Hello World!\n</code></pre></p> <p>And that's it! Check out the tutorials for more in-depth examples.</p>"},{"location":"guides/todo_list/","title":"TOOO List Agent","text":""},{"location":"guides/todo_list/#overview","title":"Overview","text":"<p>In this tutorial, we'll build an agent that manages a todo list. The full code can be found at the bottom of this page.</p>"},{"location":"guides/todo_list/#installation","title":"Installation","text":"<p>To install dopus run:</p> <pre><code>pip install dopus\n</code></pre> <p>Let's also install <code>python-dotenv</code> and <code>openai</code>:</p> <pre><code>pip install python-dotenv openai\n</code></pre>"},{"location":"guides/todo_list/#setup","title":"Setup","text":"<p>Create a <code>.env</code> file with your OpenAI API key:</p> <pre><code>OPENAI_API_KEY={YOUR_API_KEY_HERE}\n</code></pre>"},{"location":"guides/todo_list/#define-the-agent","title":"Define the Agent","text":"<p>Let's define our todo list agent with some fake TODO todos:</p> <pre><code># First load the environment variables\nimport os\nimport dotenv\ndotenv.load_dotenv()\n\nfrom dopus.provider import OpenAI\nfrom dopus.core import Agent, tool\n\nclass TodoAgent(Agent):\n    def __init__(self):\n        super().__init__()  # initialize the base Agent class\n        # fake todos\n        self.todos = [\n            {\"todo\": \"Buy groceries\", \"completed\": False},\n            {\"todo\": \"Wash dishes\", \"completed\": False}\n            {\"todo\": \"Finish project report\", \"completed\": False}\n        ]\n</code></pre>"},{"location":"guides/todo_list/#setting-the-prompt","title":"Setting the Prompt","text":"<p>All agents must override the <code>prompt</code> function. This sets the top-level or system prompt for the LLM.</p> <pre><code>class TodoAgent(Agent):\n\n    # Previous code...\n\n    def prompt(self):\n        return \"You are an AI that manages a to-do list.\"\n</code></pre>"},{"location":"guides/todo_list/#giving-the-agent-tools","title":"Giving the Agent Tools","text":"<p>The Dopus framework is built around defining tools for an agent to use. A tool is essentially a function using the <code>@tool</code> decorator.</p> <p>Here's an example of creating an <code>add_todos</code> tool:</p> <pre><code>class TodoAgent(Agent):\n\n    # Previous code...\n\n    @tool(\n        description=\"Add a new todo to the list\",\n        parameters={\n            \"todo\": {\n                \"type\": \"string\", \n                \"description\": \"The todo to add\"\n            }\n        },\n        required=[\"todo\"]\n    )\n    def add_todo(self, todo):\n        self.todos.append({\"todo\": todo, \"completed\": False})\n        return f\"Todo '{todo}' added to the list.\"\n</code></pre> <p>Info</p> <p>The return of a tool function is a string representing the result of the tool call. This result is automatically added to the context window of the LLM.</p> <p>So in this case: <pre><code>return f\"Todo '{todo}' added to the list.\"\n</code></pre>  We are telling the LLM that the tool call was successful, and the todo has been added to the list.</p> <p>Let's give the agent two more tools. A <code>send_message</code> tool so the agent to communitcate with the user and a <code>wait</code> tool to break out of the agentic loop.</p> <pre><code>class TodoAgent(Agent):\n\n    # Previous code...\n\n    @tool(\n        description=\"Communicate with the user by sending a message\",\n        parameters={\n            \"message\": {\n                \"type\": \"string\",\n                \"description\": \"The message to send\"\n            }\n        },\n        required=[\"message\"]\n    )\n    def send_message(self, message):\n        print(f\"\\nAgent: {message}\")\n        return \"Message Sent Successfully\"\n\n    @tool(description=\"\"\"Call this when you are done with the todo \n            or need to wait for the user\"\"\")\n    def wait(self):\n        self.stop() # break the agentic loop\n</code></pre> <p>Warning</p> <p>At least one of the agents tools must call <code>self.stop()</code> in order to break the agentic loop. If there are no tools that call <code>self.stop()</code> or if the LLM never calls a tool containing <code>self.stop()</code>, the agent will loop infinitely.</p>"},{"location":"guides/todo_list/#running-the-agent","title":"Running the Agent","text":"<p>Let's write a quick loop so we can try out our agent.</p> <pre><code># TodoAgent class above ^^\n\nprovider = OpenAI(os.getenv('OPENAI_API_KEY'))\nagent = TodoAgent(provider)\nwhile True:\n    message = input(\"\\nUser: \")\n    if message:\n        agent.run(message)\n</code></pre> <p>After running this code and talking with the agent, you should have output that looks something like this:</p> <pre><code>User: Hello\n\nAgent: Hello! How can I assist you with your to-do list today?\n\nUser: Can you add a todo for me?\n\nAgent: Sure! What todo would you like to add?\n\nUser: Count the r's in strawberry     \n\nAgent: The todo 'Count the r's in strawberry' has been added to your to-do list.\n</code></pre> <p>Now we have everything we need to complete the agent! We just need to build more tools for managing the todo list.</p>"},{"location":"guides/todo_list/#add-more-tools","title":"Add More Tools","text":""},{"location":"guides/todo_list/#list-todos-tool","title":"List todos Tool","text":"<pre><code>@tool(description=\"List all todos in the to-do list\")\ndef list_todos(self):\n    if not self.todos:\n        return \"Your to-do list is empty.\"\n\n    todo_list = [\n        f\"{i}. {todo['todo']} - {'completed' if todo['completed'] else 'not completed'}\"\n        for i, todo in enumerate(self.todos, 1)\n    ]\n    return \"\\n\".join(todo_list)\n</code></pre>"},{"location":"guides/todo_list/#complete-todo-tool","title":"Complete todo Tool","text":"<pre><code>@tool(\n    description=\"Mark a todo as completed\",\n    parameters={\"todo_number\": {\"type\": \"integer\", \"description\": \"The number of the todo to mark as completed\"}},\n    required=[\"todo_number\"]\n)\ndef complete_todo(self, todo_number: int):\n    if not self._is_valid_todo_number(todo_number):\n        return self._print_message(\"Error: Invalid todo number.\")\n\n    todo = self.todos[todo_number - 1]\n    todo[\"completed\"] = True\n    return f\"todo '{todo['todo']}' marked as completed.\"\n\n# Helper function\ndef _is_valid_todo_number(self, todo_number: int) -&gt; bool:\n    return 0 &lt; todo_number &lt;= len(self.todos)\n</code></pre>"},{"location":"guides/todo_list/#delete-todo-tool","title":"Delete todo Tool","text":"<pre><code>@tool(\n    description=\"Delete a todo from the to-do list\",\n    parameters={\"todo_number\": {\"type\": \"integer\", \"description\": \"The number of the todo to delete\"}},\n    required=[\"todo_number\"]\n)\ndef delete_todo(self, todo_number: int) -&gt; str:\n    if not self._is_valid_todo_number(todo_number):\n        return \"Error: Invalid todo number.\"\n</code></pre>"},{"location":"guides/todo_list/#conclusion","title":"Conclusion","text":"<p>Putting it all together and running the agent your conversation should look something like this:</p> <pre><code>User: Show me my todos\n\nAgent: Here are your todos:\n\n1. Buy groceries - not completed\n2. Finish project report - not completed\n3. Call mom - not completed\n4. Schedule dentist appointment - not completed\n\nUser: I called my mom earlier today\n\nAgent: todo 'Call mom' has been marked as completed.\n\nUser: The project report got cancelled, oh and my boss wants to do dinner tonight \n\nAgent: todo 'Finish project report' has been deleted and 'Dinner with boss' has been added to your to-do list.\n\nUser: Can you show me the updated list?\n\nAgent: Here is your updated to-do list:\n\n1. Buy groceries - not completed\n2. Call mom - completed\n3. Schedule dentist appointment - not completed\n4. Dinner with boss - not completed\n</code></pre> <p>In this tutorial, we built a to-do list manager using the Dopus framework. We covered environment setup, defining the agent, and creating tools for adding, listing, completing, and deleting todos. Thank you for following along, enjoy using Dopus!</p>"},{"location":"guides/todo_list/#full-code","title":"Full Code","text":"<pre><code>import os\nimport dotenv\ndotenv.load_dotenv()\n\nfrom dopus.provider import OpenAI\nfrom dopus.core import Agent, tool\n\nclass TodoAgent(Agent):\n    def __init__(self, provider):\n        super().__init__(provider)\n        self.todos = [\n            {\"todo\": \"Buy groceries\", \"completed\": False},\n            {\"todo\": \"Wash dishes\", \"completed\": False},\n            {\"todo\": \"Finish project report\", \"completed\": False}\n        ]\n\n    @tool(\n        description=\"Add a new todo to the to-do list\",\n        parameters={\"todo\": {\"type\": \"string\", \"description\": \"The todo to add\"}},\n        required=[\"todo\"]\n    )\n    def add_todo(self, todo):\n        self.todos.append({\"todo\": todo, \"completed\": False})\n        return f\"todo '{todo}' added to the list.\"\n\n    @tool(description=\"List all todos in the to-do list\")\n    def list_todos(self):\n        if not self.todos:\n            return \"Your to-do list is empty.\"\n\n        todo_list = [\n            f\"{i}. {todo['todo']} - {'completed' if todo['completed'] else 'not completed'}\"\n            for i, todo in enumerate(self.todos, 1)\n        ]\n        return \"\\n\".join(todo_list)\n\n    @tool(\n        description=\"Mark a todo as completed\",\n        parameters={\"todo_number\": {\"type\": \"integer\", \"description\": \"The number of the todo to mark as completed\"}},\n        required=[\"todo_number\"]\n    )\n    def complete_todo(self, todo_number: int):\n        if not self._is_valid_todo_number(todo_number):\n            return self._print_message(\"Error: Invalid todo number.\")\n\n        todo = self.todos[todo_number - 1]\n        todo[\"completed\"] = True\n        return f\"todo '{todo['todo']}' marked as completed.\"\n\n    @tool(\n        description=\"Delete a todo from the to-do list\",\n        parameters={\"todo_number\": {\"type\": \"integer\", \"description\": \"The number of the todo to delete\"}},\n        required=[\"todo_number\"]\n    )\n    def delete_todo(self, todo_number: int) -&gt; str:\n        if not self._is_valid_todo_number(todo_number):\n            return \"Error: Invalid todo number.\"\n\n        deleted_todo = self.todos.pop(todo_number - 1)\n        return f\"todo '{deleted_todo['todo']}' deleted from the list.\"\n\n    @tool(description=\"Call this when you are done with your todo or need to wait for the user\")\n    def wait(self) -&gt; None:\n        self.stop()\n\n    @tool(\n        description=\"Communicate with the user by sending a message\",\n        parameters={\"message\": {\"type\": \"string\", \"description\": \"The message to send\"}},\n        required=[\"message\"]\n    )\n    def send_message(self, message):\n        print(f\"\\nAgent: {message}\")\n        return \"Message Sent Successfully\"\n\n    def prompt(self) -&gt; str:\n        return \"You are an AI that manages a to-do list.\"\n\n    def _is_valid_todo_number(self, todo_number: int) -&gt; bool:\n        return 0 &lt; todo_number &lt;= len(self.todos)\n\nprovider = OpenAI(os.getenv('OPENAI_API_KEY'))\nagent = TodoAgent(provider)\nwhile True:\n    message = input(\"\\nUser: \")\n    if message:\n        agent.run(message)\n</code></pre>"}]}